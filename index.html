<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Endless Runner</title>
    <!-- Tailwind CSS CDN for basic layout and utility classes -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inter font for a clean look -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            overflow: hidden; /* Prevent scrolling */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: var(--tg-theme-bg-color, #f0f0f0); /* Telegram theme background */
            color: var(--tg-theme-text-color, #000000); /* Telegram theme text color */
        }
        #gameCanvas {
            background-color: var(--tg-theme-secondary-bg-color, #ffffff); /* Lighter background for canvas */
            border-radius: 1rem; /* Rounded corners for the canvas */
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1); /* Subtle shadow */
            display: block;
            touch-action: manipulation; /* Prevent default touch actions like double tap zoom */
            max-width: 95vw; /* Responsive width */
            max-height: 80vh; /* Responsive height */
            /* Aspect ratio for the canvas, adjust as needed */
            width: 100%;
            height: auto;
            aspect-ratio: 16 / 9; /* Common game aspect ratio */
        }
        .game-container {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
        }
        .game-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.7); /* Semi-transparent overlay */
            color: white;
            border-radius: 1rem;
            text-align: center;
            padding: 1rem;
            box-sizing: border-box;
            z-index: 10; /* Ensure overlay is on top */
        }
        .game-overlay h1 {
            font-size: 2.5rem;
            font-weight: bold;
            margin-bottom: 1rem;
        }
        .game-overlay p {
            font-size: 1.2rem;
            margin-bottom: 1.5rem;
        }
        .game-button {
            padding: 0.8rem 2rem;
            background-color: var(--tg-theme-button-color, #007bff); /* Telegram theme button color */
            color: var(--tg-theme-button-text-color, #ffffff); /* Telegram theme button text color */
            border: none;
            border-radius: 0.75rem; /* Rounded corners */
            font-size: 1.2rem;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        .game-button:hover {
            background-color: var(--tg-theme-button-color-hover, #0056b3); /* Slightly darker on hover */
            transform: translateY(-2px);
        }
        .game-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        #scoreDisplay {
            position: absolute;
            top: 1rem;
            left: 1rem;
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--tg-theme-text-color, #000000);
            z-index: 5;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <canvas id="gameCanvas"></canvas>
        <div id="scoreDisplay" class="hidden">Score: 0</div>

        <!-- Start Screen -->
        <div id="startScreen" class="game-overlay">
            <h1>Endless Runner</h1>
            <p>Tap anywhere on the screen to jump over obstacles!</p>
            <button id="startButton" class="game-button">Start Game</button>
        </div>

        <!-- Game Over Screen -->
        <div id="gameOverScreen" class="game-overlay hidden">
            <h1>Game Over!</h1>
            <p id="finalScore">Your Score: 0</p>
            <p id="highScore">High Score: 0</p>
            <button id="playAgainButton" class="game-button">Play Again</button>
        </div>
    </div>

    <!-- Telegram Web App SDK -->
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script>
        // Initialize Telegram Web App
        const WebApp = window.Telegram.WebApp;
        WebApp.ready(); // Inform Telegram that the Mini App is ready

        // Get canvas and its context
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Get UI elements
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const startButton = document.getElementById('startButton');
        const playAgainButton = document.getElementById('playAgainButton');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const finalScoreDisplay = document.getElementById('finalScore');
        const highScoreDisplay = document.getElementById('highScore');

        // Game variables
        let player;
        let obstacles = [];
        let score = 0;
        let highScore = localStorage.getItem('endlessRunnerHighScore') || 0; // Load high score from local storage
        let gameSpeed = 5; // Initial game speed
        let gameFrame = 0; // Used for obstacle generation timing
        let gameOver = false;
        let animationId; // To store requestAnimationFrame ID for stopping

        // Game states
        const GAME_STATE = {
            START: 'start',
            PLAYING: 'playing',
            GAME_OVER: 'gameOver'
        };
        let currentState = GAME_STATE.START;

        // Player properties
        const PLAYER_WIDTH = 40;
        const PLAYER_HEIGHT = 60;
        const PLAYER_COLOR = '#4CAF50'; // Green
        const JUMP_VELOCITY = -15; // How high the player jumps
        const GRAVITY = 0.8; // Gravity strength

        // Ground properties
        const GROUND_HEIGHT = 20;
        const GROUND_COLOR = '#8B4513'; // Brown

        // Obstacle properties
        const OBSTACLE_COLOR = '#FF5722'; // Orange-red
        const OBSTACLE_MIN_WIDTH = 30;
        const OBSTACLE_MAX_WIDTH = 80;
        const OBSTACLE_MIN_HEIGHT = 40;
        const OBSTACLE_MAX_HEIGHT = 100;
        const OBSTACLE_GAP = 200; // Minimum gap between obstacles

        // Resize canvas to fit window and maintain aspect ratio
        function resizeCanvas() {
            const containerWidth = canvas.parentElement.clientWidth;
            const containerHeight = canvas.parentElement.clientHeight;

            // Maintain a 16:9 aspect ratio
            let newWidth = containerWidth;
            let newHeight = containerWidth * (9 / 16);

            if (newHeight > containerHeight) {
                newHeight = containerHeight;
                newWidth = containerHeight * (16 / 9);
            }

            canvas.width = newWidth;
            canvas.height = newHeight;

            // Adjust game elements based on new canvas size if necessary
            // For simplicity, we'll keep player/obstacle sizes relative to a base scale
            // or use fixed values and let the canvas scaling handle it.
            // For this example, we'll use fixed values and let canvas scaling handle it.
        }

        // Player class
        class Player {
            constructor() {
                this.width = PLAYER_WIDTH;
                this.height = PLAYER_HEIGHT;
                this.x = canvas.width / 4; // Player position on X-axis
                this.y = canvas.height - GROUND_HEIGHT - this.height; // Player position on Y-axis (on ground)
                this.dy = 0; // Vertical velocity
                this.isJumping = false;
            }

            draw() {
                ctx.fillStyle = PLAYER_COLOR;
                ctx.fillRect(this.x, this.y, this.width, this.height);
            }

            update() {
                // Apply gravity if jumping or falling
                if (this.y < canvas.height - GROUND_HEIGHT - this.height || this.dy < 0) {
                    this.dy += GRAVITY;
                    this.y += this.dy;
                } else {
                    this.y = canvas.height - GROUND_HEIGHT - this.height; // Snap to ground
                    this.dy = 0;
                    this.isJumping = false;
                }
            }

            jump() {
                if (!this.isJumping) {
                    this.dy = JUMP_VELOCITY;
                    this.isJumping = true;
                }
            }
        }

        // Obstacle class
        class Obstacle {
            constructor(x) {
                this.width = Math.random() * (OBSTACLE_MAX_WIDTH - OBSTACLE_MIN_WIDTH) + OBSTACLE_MIN_WIDTH;
                this.height = Math.random() * (OBSTACLE_MAX_HEIGHT - OBSTACLE_MIN_HEIGHT) + OBSTACLE_MIN_HEIGHT;
                this.x = x;
                this.y = canvas.height - GROUND_HEIGHT - this.height; // Obstacle sits on the ground
                this.color = OBSTACLE_COLOR;
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
            }

            update() {
                this.x -= gameSpeed; // Move obstacle to the left
            }
        }

        // Collision detection (Axis-Aligned Bounding Box)
        function checkCollision(player, obstacle) {
            return player.x < obstacle.x + obstacle.width &&
                   player.x + player.width > obstacle.x &&
                   player.y < obstacle.y + obstacle.height &&
                   player.y + player.height > obstacle.y;
        }

        // Game loop
        function animate() {
            if (currentState !== GAME_STATE.PLAYING) return;

            // Update game frame and score
            gameFrame++;
            score += 0.1; // Increase score over time

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw ground
            ctx.fillStyle = GROUND_COLOR;
            ctx.fillRect(0, canvas.height - GROUND_HEIGHT, canvas.width, GROUND_HEIGHT);

            // Update and draw player
            player.update();
            player.draw();

            // Generate obstacles
            if (gameFrame % 120 === 0) { // Generate new obstacle every 120 frames (approx 2 seconds at 60fps)
                obstacles.push(new Obstacle(canvas.width + Math.random() * OBSTACLE_GAP));
            }

            // Update and draw obstacles, remove off-screen obstacles
            for (let i = 0; i < obstacles.length; i++) {
                obstacles[i].update();
                obstacles[i].draw();

                // Check for collision
                if (checkCollision(player, obstacles[i])) {
                    endGame();
                    return; // Stop animation
                }

                // Remove obstacle if it's off-screen
                if (obstacles[i].x + obstacles[i].width < 0) {
                    obstacles.splice(i, 1);
                    i--; // Adjust index after removal
                }
            }

            // Update score display
            scoreDisplay.textContent = `Score: ${Math.floor(score)}`;

            // Increase game speed gradually
            gameSpeed += 0.001;

            // Request next frame
            animationId = requestAnimationFrame(animate);
        }

        // Initialize game
        function initGame() {
            player = new Player();
            obstacles = [];
            score = 0;
            gameSpeed = 5;
            gameFrame = 0;
            gameOver = false;
            scoreDisplay.textContent = `Score: ${Math.floor(score)}`;
            scoreDisplay.classList.add('hidden'); // Hide score initially
            startScreen.classList.remove('hidden');
            gameOverScreen.classList.add('hidden');
        }

        // Start game
        function startGame() {
            currentState = GAME_STATE.PLAYING;
            startScreen.classList.add('hidden');
            scoreDisplay.classList.remove('hidden');
            // Ensure canvas is resized correctly before starting game
            resizeCanvas();
            // Clear any previous animation frame
            if (animationId) cancelAnimationFrame(animationId);
            animate(); // Start the game loop
            // Show Telegram MainButton if it's available
            if (WebApp.MainButton.isVisible) {
                WebApp.MainButton.hide();
            }
            // Show back button
            WebApp.BackButton.show();
        }

        // End game
        function endGame() {
            currentState = GAME_STATE.GAME_OVER;
            gameOver = true;
            cancelAnimationFrame(animationId); // Stop the animation loop

            // Update high score
            if (Math.floor(score) > parseInt(highScore)) {
                highScore = Math.floor(score);
                localStorage.setItem('endlessRunnerHighScore', highScore); // Save high score
            }

            finalScoreDisplay.textContent = `Your Score: ${Math.floor(score)}`;
            highScoreDisplay.textContent = `High Score: ${highScore}`;
            gameOverScreen.classList.remove('hidden');
            scoreDisplay.classList.add('hidden'); // Hide score display

            // Show Telegram MainButton for "Play Again"
            WebApp.MainButton.setText('Play Again');
            WebApp.MainButton.onClick(resetGame);
            WebApp.MainButton.show();
        }

        // Reset game
        function resetGame() {
            initGame(); // Re-initialize game state
            startGame(); // Start the game
        }

        // Event Listeners
        startButton.addEventListener('click', startGame);
        playAgainButton.addEventListener('click', resetGame);

        // Tap/Click to jump
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault(); // Prevent scrolling on touch
            if (currentState === GAME_STATE.PLAYING) {
                player.jump();
            }
        });
        canvas.addEventListener('mousedown', (e) => {
            if (currentState === GAME_STATE.PLAYING) {
                player.jump();
            }
        });

        // Handle Telegram MainButton click for initial start
        WebApp.MainButton.setText('Start Game');
        WebApp.MainButton.onClick(startGame);
        WebApp.MainButton.show();

        // Handle Telegram BackButton click
        WebApp.BackButton.onClick(() => {
            if (currentState === GAME_STATE.PLAYING || currentState === GAME_STATE.GAME_OVER) {
                // If in game or game over, go back to start screen
                initGame();
                WebApp.MainButton.setText('Start Game');
                WebApp.MainButton.onClick(startGame);
                WebApp.MainButton.show();
                WebApp.BackButton.hide();
            } else {
                // If on start screen, close the Mini App
                WebApp.close();
            }
        });

        // Initial setup on window load
        window.onload = function() {
            resizeCanvas(); // Set initial canvas size
            initGame(); // Initialize game state
            // Listen for window resize to make the canvas responsive
            window.addEventListener('resize', resizeCanvas);

            // Set Telegram theme parameters
            const themeParams = WebApp.themeParams;
            if (themeParams) {
                document.documentElement.style.setProperty('--tg-theme-bg-color', themeParams.bg_color);
                document.documentElement.style.setProperty('--tg-theme-text-color', themeParams.text_color);
                document.documentElement.style.setProperty('--tg-theme-secondary-bg-color', themeParams.secondary_bg_color);
                document.documentElement.style.setProperty('--tg-theme-button-color', themeParams.button_color);
                document.documentElement.style.setProperty('--tg-theme-button-text-color', themeParams.button_text_color);
            }
        };

    </script>
</body>
</html>
